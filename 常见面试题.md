#### 常见面试题

##### 1.数据库，主要是Mysql

1. sql场景题，主要是多表联查

2. 了解过索引吗？

   索引分为聚簇索引和非聚簇索引。

   | 聚簇索引                   | 非聚簇索引                                          |
   | -------------------------- | --------------------------------------------------- |
   | 主键索引：以表的id作为索引 | 普通索引                                            |
   |                            | 唯一索引                                            |
   |                            | 组合索引：最左前缀匹配   遇到betwen and >< 不会匹配 |
   |                            | 全文索引                                            |
   |                            | 空间索引                                            |

3. 索引的原理?

   往b tree和 b+tree  每个叶子节点指向下一个子节点。

   索引引擎：innodb和mysiam，往下深入了解。

   mysql的事务默认隔离级别是可重复读(repeatable read),会出现幻读问题.

   | mysiam                           | innodb                         |
   | -------------------------------- | ------------------------------ |
   | 5.5默认引擎是mysiam              | 5.7的默认引擎是innodb          |
   | 支持表级锁                       | 支持行级锁，解决了幻读问题     |
   | 不支持事务                       | 支持事务                       |
   | 不支持外键                       | 支持外键                       |
   | 非聚簇索引，以B+tree作为索引结构 | 聚簇索引，B+tree，必须要有主键 |
   | 支持全文索引                     | 不支持全文索引                 |

   ##### 如何选择？

   1. 如果要支持事务，就选择innodb，不考虑事务就选择mysiam。

   2. 如果表中大多数都是读查询，就考虑mysiam，如果有读也有写，就选择innodb。

   	3. 系统崩溃后，mysiam恢复起来更困难.

4. 事务隔离级别

   | 事务隔离级别               | 脏读 | 不可重复读 | 幻读 | 加锁读 |
   | -------------------------- | ---- | ---------- | ---- | ------ |
   | 读未提交(read-uncommitted) | √    | √          | √    | ×      |
   | 读已提交(read-commited)    | ×    | √          | √    | ×      |
   | 可重复读(repeatable read)  | ×    | ×          | √    | ×      |
   | 可串行化(serializable)     | ×    | ×          | ×    | √      |

   脏读:( 针对未提交数据)有两个事务对同一个数据进行操作，如果一个事务对数据进行了更新，这时另一个事务读取了数据，然后第一个事务进行了回滚，那么第二个事务读取的数据就是脏数据，也就是我们所说的“脏读”.

   不可重复读:(针对其他提交前后，读取数据本身的对比)不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题.

   幻读:（针对其他提交前后，读取数据条数的对比） 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题.

##### 2.java基础

1. java集合list，set区别，主要是hashMap源码，线程安全的map，比如:HashTable,Collections.synchronizedMap,CurrentHashMap
2. 多线程:原子性，可见性，有序性。

- 线程的创建方式，三种。
  - implements Runnable接口  重写run方法。Thread thread = new Thread(stu); thread.start();
  - implements Callable接口  重写call方法，有返回值。
  - extends Thread 方法  启动线程:new 子类，调用start()方法。
- 常用的线程池，newFixThreadPool,newCacheThreadPool等，使用线程池的好处。
- synchronized的底层实现原理。
- 锁升级的过程。

3. jvm内存结构。

   - 三种算法:标记清除，标记复制，标记整理区别及用处。

     - 标记清除:将标记的对象进行垃圾回收。缺点：产生大量不连续的内存碎片.
     - 标记复制:将一块内存分为大小相等的两块，只用其中一块进行垃圾回收，并将存活的对象移动到另一边,主要用于新生代的垃圾回收。缺点：比较浪费空间，只有一半内存可用。
     - 标记整理:在标记清除的基础上，由于标记清除产生了大量不连续的内存碎片，标记整理是存活的对象都向一端移动，并清理掉边界以外的内存。

   - 两个判断垃圾是否存活:引用计数器，可达性分析。

     * 引用计数器:给对象添加一个引用计数器，每有一个对象引用时，计数器就会加1，引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能再被使用的，即进行垃圾回收。
     * 可达性分析:通过GC ROOT(即垃圾回收的根节点)，往下走，能走到的对象，说明这个对象是可达的，然后，继续往下走，没有被走到的对象说明是不可达的，不可达的对象就是要被回收的对象。

   - 堆内存：分为新老代(Minor GC)，老年代(Full GC)。

     * 新生代：eden:s0:s1:8:1:1，采用的是标记复制算法， 因为新生代迭代速度比较快，朝生夕死，存活的数量比较少，所以采用标记复制的算法效率比较高。
     * 老年代：主要是标记清除算法。

   - 为什么新生代需要两个survivor区？
     如果只有一个survivor区的话，每次执行gc后，存活的对象都被放在这个survivor区中，会导致内存使用的不连续，即产生碎片。而使用两个survivor区的话，每次执行gc后，eden区和s0区的存活对象就被存放在s1区中，避免了碎片的产生。

   - 新生代垃圾回收的过程?

     ​	新创建的对象会放在eden区（大对象会直接放入老年代），当eden区满时触发一次Minor GC垃圾回收，这时存活的对象会放在s0区，并且将存活的年龄+1，当eden区再一次满时，会将eden和s0进行垃圾回收，并用复制算法将存活的对象放入s1区，此时，将s0和s1位置交换，即现在的s1变为原来的s0（保证有一块内存是空的），当对象存活的年龄大于16会直接放入老年代。

##### 3.项目

* spring

  1. spring的生命周期
  2. 说一下spring的ioc，DI 。 工厂+反射
  3. springaop的原理，jdk动态代理和cglib代理。
  4. 为什么要用spring？spring有什么好处？ 解耦，减少内存的消耗。
  5. spring的声明式事务有了解过吗？

* springmvc

  1. springmvc的加载流程。
  2. 过滤器，拦截器，监听器。
  3. springmvc的常用注解。

* mybatis

   1. mybatis是怎样将mapper.xml和dao进行映射的？ namespace 命名空间和id绑定。

   2. mabatis 的好处在哪里？

   3. mybatis是如何防止sql注入的问题的？$和#区别？

         select id, username, password, role from user where username=? and password=?

      ​	MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。

      ​	#拼接sql是使用字符串的方式，$是使用传过来的值拼接到sql语句，所以$有可能会导致sql注入的问题,所以能不使用尽量不使用$。简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。

* redis

  1. redis的数据结构有哪些? String list set hash zhash
  2. redis在项目中的使用方式?
  3. redis的RDB和AOF的区别？

* shiro

  1. shiro是如何实现认证和授权的？
  2. 在项目中具体是怎么使用shiro的？
  3. shiro的原理有了解过吗？

  





